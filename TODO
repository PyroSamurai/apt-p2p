Consider what happens when we are the closest node.

In some of the actions it is unclear what happens when we are one of the
closest nodes to the target key. Do we store values that we publish
ourself?


Add all cache files to the database.

All files in the cache should be added to the database, so that they can
be checked to make sure nothing has happened to them. The database would
then need a flag to indicate files that are hashed and available, but
that shouldn't be added to the DHT.


Packages.diff files need to be considered.

The Packages.diff/Index files contain hashes of Packages.diff/rred.gz 
files, which themselves contain diffs to the Packages files previously 
downloaded. Apt will request these files for the testing/unstable 
distributions. They need to either be ignored, or dealt with properly by 
adding them to the tracking done by the AptPackages module.


PeerManager needs to download large files from multiple peers.

The PeerManager currently chooses a peer at random from the list of 
possible peers, and downloads the entire file from there. This needs to 
change if both a) the file is large (more than 512 KB), and b) there are
multiple peers with the file. The PeerManager should then break up the 
large file into multiple pieces of size < 512 KB, and then send requests 
to multiple peers for these pieces.

This can cause a problem with hash checking the returned data, as hashes 
for the pieces are not known. Any file that fails a hash check should be 
downloaded again, with each piece being downloaded from different peers 
than it was previously. The peers are shifted by 1, so that if a peers 
previously downloaded piece i, it now downloads piece i+1, and the first 
piece is downloaded by the previous downloader of the last piece, or 
preferably a previously unused peer. As each piece is downloaded the 
running hash of the file should be checked to determine the place at 
which the file differs from the previous download.

If the hash check then passes, then the peer who originally provided the 
bad piece can be assessed blame for the error. Otherwise, the peer who 
originally provided the piece is probably at fault, since he is now 
providing a later piece. This doesn't work if the differing piece is the 
first piece, in which case it is downloaded from a 3rd peer, with 
consensus revealing the misbehaving peer.
